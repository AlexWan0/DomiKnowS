# Model Declaration

- [Model Declaration](#model-declaration)
  - [Class Overview](#class-overview)
  - [Sensor](#sensor)
    - [Initiate a Sensor](#initiate-a-sensor)
    - [Invoke a Sensor](#invoke-a-sensor)
    - [`forward()`](#forward)
      - [`ReaderSensor`](#readersensor)
      - [`ConcatSensor`](#concatsensor)
      - [Overriding `forward()`](#overriding-forward)
    - [Caching output](#caching-output)
    - [Managing invocation path](#managing-invocation-path)
    - [Converting input (WIP)](#converting-input-wip)
  - [Sensor Assignment to Property](#sensor-assignment-to-property)
  - [Learner](#learner)
  - [Reader](#reader)
  - [Multiple Assigment Convention](#multiple-assigment-convention)
  - [Detach](#detach)
    - [`detach` use cases](#detach-use-cases)

## Class Overview

- package `regr.sensor`:
- `Sensor`:
- `Learner`:

## Sensor

`Sensor`s are procedures to access external resources and procedures. For example, reading from raw data, feature engineering staffs, and preprocessing procedures.
"Sensors" are looked at as blackboxes in a program.
Users use sensors as [callable objects](#callable).
Underlying `forward()` function will be used to calculate an output. One can override `forward()` function to customize how the sensor get the output.
Base classes of `Sensor` will handle details like caching calcuated results, managing invocation path, and converting input.

### Initiate a Sensor

Sensors should always be initiated by a implmented class, rather the abstract `Sensor` or any base sensor.

```python
sensor = ImplementedSensor(...)
```

The framework contains some default sensors that users can use directly. Users can also customize their own by extending these sensors.

### Invoke a Sensor

A `Sensor` is a callable object that can be invoked by passing a `dict` context variable or a `DataNodeBuilder`.
One can invoke it by

```python
context = {...}  # input data organized in a python dictionary
output = sensor(context)
```

Sensor will calcuate `output` based on its implementation of `forward()` function.
The `context` will be updated with a `sensor.fullname` key and `output` value pair as a caching mechanism.

```python
assert context[sensor.fullname] == output
```

### `forward()`

`forward()` defines the output calculation of the sensor.
Defaultly, it takes the same `context` as the sensor being invoke with.

For example, following are some basic sensors.

#### `ReaderSensor`

`ReaderSensor` retieves the value with a key, defined when being initiated, from the `context`.

```python
sensor = ReaderSensor(key='raw_input')
context = {'raw_input': 'hello world'}

output = sensor(context)

assert output == 'hello world'
```

#### `ConcatSensor`

`ConcatSensor` concatenates the input tensors (at the last dimension).

```python
sensor = ConcatSensor(feat_sensor1, feat_sensor2, key='raw_input')
context = {
  feat_sensor1.fullname: torch.random(5, 4, 3),
  feat_sensor2.fullname: torch.random(5, 4, 7)}

output = sensor(context)

assert output.shape == (5, 4, 10)
```

#### Overriding `forward()`

One can override `forward()` function to customize sensor. For example, one can create a random number generator:

```python
import torch

class RNGSensor(Sensor):
  def __init__(self, shape):
    self.shape=shape

  def forward(self, *args):
    return torch.random(shape)

sensor = RNGSensor(shape=(5, 5))

output1 = sensor({})
output2 = sensor({})

assert output1.shape == (5, 5)
assert output1 != output2
```

However, `context` will cache output (as will be detailed later). If the identical `context` is passed, the output will be the same, unless force re-calculate is indicated by passing `force=True`.

```python
context = {}

output1 = sensor(context)
output2 = sensor(context)

assert output1 == output2

output3 = sensor(context, force=True)

assert output1 != output3
```

### Caching output

`context` is used as a source of input and a cache of outputs at the same time.
All the `output` generated by `sensor` will be updated to the `context` using `sensor.fullname` as a key and `output` as the value automatically.
If the key `sensor.fullname` exist, the associated value will be return without re-calculating, unless `force=True` is spesified when incoking.

```python
output = sensor(context)

assert context[sensor.fullname] == output

output = sensor(context, force=True)
```

The cache effect will be propagate to upper level object if there isn't a value yet.
For example, if the sensor is assigned to a property of a concept in a graph, the output of the sensor will be propagate to the property `sensor.sup` with key `sensor.sup.fullname`, further to the concept `sensor.sup.sup` with key `sensor.sup.sup`, etc.

```python
concept = Concept()
concept['prop'] = sensor
context = {}
output = sensor(context)

assert context[sensor.fullname] == output
assert context[concept['prop'].fullname] == output
assert context[concept.fullname] == output
```

### Managing invocation path

In model declaration, the user will need to assign sensors to properties.
However, that should not nessesearily reflect the order of calculation that is needed.
Sensors just look at `context` and try to fetch whatever they need as input.
Managing one should be call before another is a headache.

Some base sensor extention (`TorchSensor`) are able to trace what it need beforehand and invoke automatically. Such automation forms an invocation path.

`TorchSensor` initiates with extra variables `*pres`

### Converting input (WIP)

As our program requires readers as the starting point, you have to write some reader classes that interacts with our dataset.
Readers will have a function for each train, valid and test set that returns a generator over separate parts of the dataset.
a graph (`Graph` object) with its concepts (`Concept` objects) having properties (`Property` objects accessed as items of concepts) connected to raw data sensors (`Sensor` objects).

## Sensor Assignment to Property

Sensors can be assigned to properties

```python
reader = Reader()
sentence['raw'] = ReaderSensor(reader, 'sentence')
sentence.contains()[word] = SimpleTokenizorSensor('raw')
people['label'] = LabelReaderSensor(reader, 'people')
organization['label'] = LabelReaderSensor(reader, 'organization')
work_for['label'] = LabelReaderSensor(reader, 'work_for')
```

## Learner

The learning declaration of the program is where you will define the properties of your graph nodes and define edge functionalities. This part will be a combination of reader sensor, edge transformer, execution sensor and learners.

a graph (`Graph` object) with its concepts (`Concept` objects) having properties (`Property` objects accessed as items of concepts) connected to learners (`Learner` objects) and pass through sensors (`Sensor` objects). Now the graph is considered a *full program*.
Example:

```python
sentence['embed'] = BertLearner('raw')
people['label'] = LogisticRegression('embed')
organization['label'] = LogisticRegression('embed')
work_for['label'] = LogisticRegression('embed')
```

## Reader

To start a chain of learning algorithm first you have to assign a reader sensor to a property of your root node in the graph. The reader job is to initialize the examples for execution of the learning model. The output of this reader sensor is an example per execution.

## Multiple Assigment Convention

## Detach

In the graph - sub-graph - concept - property - sensor hierarchy, each component can trigger `detach` to remove its direct children components. For example,

```python
with Graph() as graph:
  concept = Concept()

graph.detach(concept) # remove concept from graph
```

It should be notice that `concept.sup` will also be unset.

If no spesific child passed, all leaf nodes are removed. For example, remove all sensors in a graph:

```python
graph.detach()
```

If no spesific child passed and `all=True`, all direct children will be remove. For example, remove all properties of a concept:

```python
concept.detach(all=True)
```

### `detach` use cases

Since multiple assignment would not override the existing sensor, if you want to remove a sensor, `.detach(sensor)` is what you need.

Graph can be reuse by different part of program. In case it will be used multiple time in one python program and you have a different set of sensors and learners to assign to the properties. You need to reset the graph by removing all the sensors and learners by `detach()`.

```python
graph.detach()
```
